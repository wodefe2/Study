	对快速排序理解：

本文的目的是希望能够通过以下的基本原则独立写出一个主元在右侧的快速排序算法。

众所周知，快速排序用到了分治的思想，但我认为分治不是他能够进行“排序”的原因，分治是的“快”的实现方式。

快排的**基本思想**是，一次排好一个数（这个数就称为主元pivot)，那我只需要将每个数都放在他的位置上就可以了。

假设排序的目标是从左到右依次递增，那么如何判断我排好了一个数呢，判断方法就是该数的**左边的数都小于等于该数，右边的数都大于等于该数**。注意我这里说的“左边”和“右边”都是相对于主元而言的，”左边“和”右边“均存在一个”边界“，我们每次安置一个数（该数称为主元pivot）时，都是在这个范围之内来做的。**基本上，快排的一次迭代就是将主元放置在特定范围内的合适位置上**。好，到这里，相信大家对如何操作是懵逼的，那我们看下面的数。

| index | 0    | 1    | 2    | 3    | 4           |
| ----- | ---- | ---- | ---- | ---- | ----------- |
| value | 5    | 2    | 1    | 3    | *4（主元）* |

为了方便操作，我们选择每次都排好数组最右边的数。即4，现在我要将4放到合适的位置上去。判断4是不是放到位置的标准是**左边的数都小于等于4，右边的数都大于4**。

这是第一轮遍历，左边界是0，右边界是3（不包含主元），那我们先从最左边开始遍历，**左指针用来保证左边的数都小于主元**。

|       | 左指针↓ |      |      |      |             |
| ----- | ------- | ---- | ---- | ---- | ----------- |
| index | 0       | 1    | 2    | 3    | 4           |
| value | 5       | 2    | 1    | 3    | *4（主元）* |



5大于4，那么5应该在4的右边，也就是5可能需要和4交换位置，好，左边的指针在5这里停下。

|       | 左指针↓                      |      |      |      |             |
| ---------------------------- | ---- | :--- | ---- | ----------- | ---------------------------- |
|index| 0 | 1 | 2 | 3 | 4 |
|value| 5 | 2    | 1    | 3    | *4（主元）* |

接下来检查右边，**右指针用来保证右边的数都大于主元**。

|       | 左指针↓ |      |      | 右指针↓ |             |
| ----- | ------- | :--- | ---- | ------- | ----------- |
| index | 0       | 1    | 2    | 3       | 4           |
| value | 5       | 2    | 1    | 3       | *4（主元）* |

3小于4，应该放在4的左边，正好5需要在4的右边，3需要在4的左边，那么我们将他们调换一个位置岂不是美滋滋。好，我们将其调换位置。

|       | 左指针↓ |      |      | 右指针↓ |             |
| ----- | ------- | :--- | ---- | ------- | ----------- |
| index | 0       | 1    | 2    | 3       | 4           |
| value | 3       | 2    | 1    | 5       | *4（主元）* |

好，现在我们保证了index是0和3的位置对于主元4来说都是合适的（3小于4,5大于4）。左指针继续向右移动。
|       |      | 左指针↓ |      | 右指针↓ |             |
| ----- | ---- | :------ | ---- | ------- | ----------- |
| index | 0    | 1       | 2    | 3       | 4           |
| value | 3    | 2       | 1    | 5       | *4（主元）* |

2是小于4的，继续向右移动。
|       |      |      | 左指针↓ | 右指针↓ |             |
| ----- | ---- | :--- | ------- | ------- | ----------- |
| index | 0    | 1    | 2       | 3       | 4           |
| value | 3    | 2    | 1       | 5       | *4（主元）* |

1也是小于4的，继续向右移动。
|       |      |      |      | 左指针↓右指针↓ |             |
| ----- | ---- | :--- | ---- | -------------- | ----------- |
| index | 0    | 1    | 2    | 3              | 4           |
| value | 3    | 2    | 1    | 5              | *4（主元）* |

5是大于主元的，左指针停下。这时发现左指针和右指针撞在一起了。由于左指针遇到大于4的数时就会停下，此时可以保证5的左边都是小于4的，而5大于4，且现在5在4的左边，那么只需要交换5和4的位置，即可放置好主元，那么我们交换5和4的位置。

|       |      |      |      | 左指针↓右指针↓ |      |
| ----- | ---- | :--- | ---- | -------------- | ---- |
| index | 0    | 1    | 2    | 3              | 4    |
| value | 3    | 2    | 1    | *4（主元）*    | 5    |

此时4就处于一个安置好的位置了。接下来，我们注意到4的左边都是小于4的数，4的右边都是大于4的数。那么我们分别对4的“左边”和4的“右边”进行排序即可。由于我们已知大于4的数只有一个，且已经位于最右边，故右边已经排好序了。只要对左边进行排序即可。对左边重复上述方法，只是此时，主元变为“左边”的”最右边“的数了。
|       | 左指针↓ | 右指针↓ |                   |               |               |
| ----- | ------- | :------ | ----------------- | ------------- | ------------- |
| index | 0       | 1       | 2                 | 3             | 4             |
| value | 3       | 2       | 1（左范围的主元） | 4（排序完毕） | 5（排序完毕） |

3大于1，左指针停下。

|       | 左指针↓ | 右指针↓ |                   |               |               |
| ----- | ------- | :------ | ----------------- | ------------- | ------------- |
| index | 0       | 1       | 2                 | 3             | 4             |
| value | 3       | 2       | 1（左范围的主元） | 4（排序完毕） | 5（排序完毕） |

右指针2大于1，继续往左。
|       | 左指针↓右指针↓ |      |                   |               |               |
| ----- | -------------- | :--- | ----------------- | ------------- | ------------- |
| index | 0              | 1    | 2                 | 3             | 4             |
| value | 3              | 2    | 1（左范围的主元） | 4（排序完毕） | 5（排序完毕） |

3仍然大于1，此时发现左右指针重合，由于当前位置的3大于主元，且右指针保证了右边的数都大于1，此时可以将左右指针的数与1交换。
|       |               |      |      |               |               |
| ----- | ------------- | :--- | ---- | ------------- | ------------- |
| index | 0             | 1    | 2    | 3             | 4             |
| value | 1（排序完毕） | 2    | 3    | 4（排序完毕） | 5（排序完毕） |

此时发现只剩右边需要排序。
|       |               | 左指针↓右指针↓ |           |               |               |
| ----- | ------------- | :------------- | --------- | ------------- | ------------- |
| index | 0             | 1              | 2         | 3             | 4             |
| value | 1（排序完毕） | 2              | 3（主元） | 4（排序完毕） | 5（排序完毕） |

2小于3，因此左指针继续移动。

|       |               | 右指针↓ | 左指针↓   |               |               |
| ----- | ------------- | :------ | --------- | ------------- | ------------- |
| index | 0             | 1       | 2         | 3             | 4             |
| value | 1（排序完毕） | 2       | 3（主元） | 4（排序完毕） | 5（排序完毕） |

此时发现左指针到了主元的位置。就是说，左边的数都小于了主元，此时表明主元已经在正确的位置上了。迭代结束。



总结：

快排的**基本思想**：一次排好一个数（这个数称为主元pivot)。

如何判断排好了一个数：确认该数的**左边的数都小于等于该数，右边的数都大于等于该数**。